## Interfaccia Web: scelte progettuali

Per la realizzazione dell'interfaccia web del nostro progetto, abbiamo scelto di utilizzare HTML e CSS per il front-end. Questi linguaggi, noti per la loro semplicità, ci consentono di creare un'interfaccia utente efficace. Un vantaggio significativo è la loro integrazione con Python e Flask, il che facilita una chiara separazione tra front-end e back-end nello sviluppo dell'applicazione. Come detto, quindi, abbiamo optato per Python come linguaggio per il back-end per diversi motivi. È ampiamente riconosciuto per la sua facilità di sviluppo e offre una vasta gamma di librerie per implementare funzionalità specifiche. Python supporta l'integrazione con Nebula e una cosa molto importante, per cui abbiamo deciso di utilizzare Python, è il fatto che dispone di vari Framework web come Flask, Django e Web2py. Questi Framework consentono lo sviluppo rapido di funzionalità come la gestione degli utenti, l'autenticazione, l'interfacciamento con il database, ed altro.

### La scelta del Framework

Come abbiamo appena detto, Python offre una vasta gamma di framework, che possono essere utilizzati, però noi abbiamo deciso di focalizzare la nostra attenzione su Flask dal momento che, offre:

- **Semplicità e leggerezza**: è progettato per essere semplice da usare e facile da imparare
- **Integrazione con Nebula e Python**: siccome Nebula è scritto in Go, e Python è il linguaggio che abbiamo scelto per questo progetto, Flask offre una buona integrazione con Python. Quindi è possibile scrivere delle funzioni per interagire con Nebula, utilizzando Python.
- **Flessibilità**: Flask è altamente flessibile e modulare. E' possibile aggiungere le estensioni necessarie per gestire l'autenticazione, la gestione delle sessioni e altre funzionalità senza dover adottare un intero framework con funzionalità che potrebbero non essere necessarie per il nostro progetto.
- **Supporto per Jinja2**: Flask supporta nativamente il motore di template Jinja2, permettendo di creare pagine web dinamiche con facilità.
- **Sicurezza**: Flask offre protezioni di base contro attacchi comuni come l’iniezione SQL e gli attacchi CSRF. Inoltre, Flask-WTF e Flask-Login sono estensioni popolari che offrono funzionalità di sicurezza aggiuntive.

Quando si sviluppa un'applicazione web con Flask, è essenziale mantenere una struttura organizzata per facilitare la gestione del codice e delle risorse. All'interno della cartella del progetto, oltre al file principale _[app.py](http://app.py)_, ci sono due cartelle fondamentali: _templates_ e _static_. La cartella _templates_ è utilizzata per memorizzare i file di template HTML. Come detto prima, Flask utilizza il motore di template Jinja2 per renderizzare questi file, permettendo di inserire variabili, cicli e logica di controllo all'interno del tuo HTML. Questo è molto utile per creare pagine web dinamiche che possono cambiare in base ai dati passati dal server. D'altra parte, la cartella _static_ è utilizzata per memorizzare i file statici come CSS, JavaScript e immagini. Questi file vengono serviti direttamente ai client web senza bisogno di elaborazione da parte del server, migliorando così le prestazioni del sito.

All'interno del nostro codice viene innanzitutto inizializzato l'oggetto Flask, e dopodiché viene configurato per utilizzare un database PostgreSQL e una chiave segreta per la sessione. Una cosa molto importante in Flask sono le route, i quali sono i punti di accesso alle diverse funzioni e risorse dell'applicazione web. Ogni route corrisponde ad un URL specifico che l'applicazione può gestire. Per poter definire una route useremo il decoratore '@app.route()' seguito dall'URL desiderato come argomento. All'interno del decoratore, oltre all'URL, è possibile specificare i metodi HTTP (GET e POST). Questa specificazione è molto importante perché determina come l'applicazione web risponde alle diverse tipologie di richieste che possono essere inviate al server. Una scelta che è stata presa è stata quella di realizzare due route per quanto riguarda l'assegnamento e la revoca della macchina, questo perché in questo modo andiamo a separare le responsabilità ovvero la route '_/assign_' si occupa di mostrare le opzioni e le possibili scelte all'utente autorizzato, mentre la route '_/assignment/ <'idut'>_' gestisce l'azione effettiva e l'elaborazione dei dati. Abbiamo anche deciso di definire due route per le dashboard, ovvero una route che porta alla Dashboard normale, ed un'altra che ci porta alla Dashboard_admin. Questa separazione è importante per distribuire responsabilità in modo chiaro. La dashboard normale, pensata per l'utente standard, è progettata per mostrare la lista delle possibili macchine disponibili, mentre la dashboard_admin oltre a fornire la lista delle macchine, offre funzionalità avanzate come la possibilità di aggiungere utenti, di gestire le macchine da assegnare o revocare ad un utente. Dunque, differenziare le due route permette di gestire in modo efficace e sicuro l'accesso delle diverse categorie di utenti. Questa cosa accade anche per la pagina che mostra le regole di firewall, proprio perché l'admin ha delle funzionalità avanzate, che l'utente normale non può usare. Una possibile ottimizzazione potrebbe essere l'utilizzo di una struttura più flessibile che utilizza una singola route per entrambe le dashboard, ma con la gestione dinamica dei contenuti basata sul ruolo dell'utente. Ad esempio, potremmo implementare un sistema di autorizzazione che, dopo aver verificato il ruolo dell'utente (standard o admin), determina dinamicamente quali sezioni della dashboard mostrare e quali azioni consentire. Questo approccio non solo semplifica il codice eliminando la duplicazione delle route, ma anche centralizza il controllo degli accessi, migliorando la manutenibilità e la scalabilità del sistema.

### PopulateDB e scelte progettuali

Per il nostro progetto abbiamo ipotizzato che ci sia uno script, che legge dei file di configurazione iniziali, forniti dall'azienda utilizzatrice della nostra web app. Questi file sono in formato JSON, e tramite i dati che recupera da questi file, vada a popolare le tabelle presenti all'interno del nostro database. La scelta di utilizzare questo script che popola in maniera automatica le tabelle del database permette di avere:

- **Automazione ed efficienza:** utilizzare uno script consente di automatizzare il popolamento del database. Questo è molto vantaggioso quando si hanno grandi quantità di dati o quando i dati vengono aggiornati frequentemente. Inoltre lo script permette di ridurre il rischio di errori umani e consente di risparmiare tempo e sforzi.
- **Scalabilità:** Con uno script, è più facile gestire grandi volumi di dati. Si può facilmente modificare lo script per gestire più dati o per integrare nuovi campi senza dover ripetere manualmente il processo di inserimento dei dati.
- **Consistenza dei dati:** garantisce la coerenza e la validità dei dati inseriti nel database, e questo è molto importante quando si tratta di dati strutturati in modo complesso.

La scelta di utilizzare JSON, per i file di configurazione iniziale, è dovuta a diversi motivi che lo differenziano dagli altri, ovvero:

- **Struttura dei dati:** JSON è particolarmente adatto per dati strutturati come i nostri. Ogni oggetto JSON rappresenta chiaramente una singola entità con attributi specifici. Questa struttura facilita la comprensione e la manipolazione dei dati sia per gli sviluppatori che per le macchine.
- **Interoperabilità:** JSON è ampiamente supportato da diversi linguaggi di programmazione e framework. Ciò semplifica l'integrazione dei dati estratti nei nostri processi di sviluppo web, garantendo che sia facile lavorare con i dati sia lato front-end che lato back-end.

Nel nostro codice, abbiamo implementato diverse funzioni per recuperare i dati. La scelta di utilizzare diverse funzioni è dovuta al fatto che ci sono più file di configurazione iniziali. In particolare, abbiamo una funzione chiamata _**populate_utenti_from_json,**_ che legge il file JSON relativo agli utenti, ed una funzione chiamata _**populate_tables_from_json,**_ che legge il file JSON relativo alle macchine, e nel quale viene letto anche un file YAML, per popolare le tabelle delle regole di Firewall.

Però prima di poter popolare le tabelle, esse devono essere distrutte (per evitare problemi di duplicazione) e create tramite la CREATE TABLE. Come possiamo vedere per alcuni attributi è stato necessario utilizzare le clausole ‘NOT NULL’, per far si che alcuni campi (per esempio _username, nome, cognome)_ non siano nulli, ‘UNIQUE’, in modo tale da garantire che i valori in una colonna siano unici tra tutte le righe della tabella (per esempio per l’_username,_ perché altrimenti causerebbero dei conflitti nel caso avessimo più utenti con lo stesso username), ed infine ‘ON DELETE CASCADE’, che è utilizzata nelle definizioni delle chiavi esterne per specificare come gestire automaticamente le eliminazioni delle righe nelle tabelle collegate quando una riga correlata nella tabella principale viene eliminata, per esempio, l’aggiunta della clausola all’_utente_id_ nella tabella _USA_ indica che se viene eliminata una riga dalla tabella _UTENTE_ con un certo _id_, tutte le righe nella tabella _USA_ che fanno riferimento a questo _id_ verranno eliminate automaticamente. Questo mantiene l'integrità referenziale tra le tabelle e previene i riferimenti "orfani".